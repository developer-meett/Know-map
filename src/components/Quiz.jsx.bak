import React, { useMemo, useState } from 'react';
import { useNavigate } from 'react-router-dom';
          console.log(`Backup submission URL (if primary fails): ${backendUrl}`);
          
          // Prepare the request options
          const requestOptions = {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${idToken}`
            },
            body: JSON.stringify({
              quizId: quizId,
              answers: answersObject
            })
          };
          
          // Try with the first URL format
          try {
            console.log("Trying primary URL format...");
            const response = await fetch(submitUrl, requestOptions);
            
            if (!response.ok) {
              const errorData = await response.text();
              console.error(`Backend error with primary URL [${response.status}]:`, errorData);
              
              // Try the backup URL format
              console.log("Primary URL failed, trying backup URL format...");
              const backupResponse = await fetch(backendUrl, requestOptions);
              
              if (!backupResponse.ok) {
                const backupErrorData = await backupResponse.text();
                console.error(`Backend error with backup URL [${backupResponse.status}]:`, backupErrorData);
                throw new Error(`Backend error: ${backupResponse.status} - ${backupErrorData}`);
              }
              
              return backupResponse; // Return the successful backup response
            }
            
            return response; // Return the successful primary response
          } catch (fetchError) {
            console.error("Fetch operation failed:", fetchError);
            throw fetchError;
          }
          
          // This code will not be reached due to the return statements above
          const response = await fetch(submitUrl, requestOptions);

          if (!response.ok) {
            const errorData = await response.text();
            console.error(`Backend error [${response.status}]:`, errorData);
            throw new Error(`Backend error: ${response.status} - ${errorData}`);
          }

export default function Quiz({ items, onComplete }) {
  const navigate = useNavigate();
  const { user } = useAuth();
  const qs = useMemo(() => (Array.isArray(items) && items.length ? items : defaultQuestions), [items]);
  
  const [current, setCurrent] = useState(0);
  const [selected, setSelected] = useState(null);
  const [userAnswers, setUserAnswers] = useState([]);
  const [submitting, setSubmitting] = useState(false);
  const [error, setError] = useState('');

  const q = qs[current];
  const total = qs.length;
  const isLast = current === total - 1;

  const handleSelect = (idx) => setSelected(idx);

  const handleNext = () => {
    if (selected === null) return;
    
    // Store the user's answer
    const newAnswers = [...userAnswers, selected];
    setUserAnswers(newAnswers);

    if (isLast) {
      // Quiz finished - process results
      processResults([...newAnswers]);
    } else {
      setCurrent((c) => c + 1);
      setSelected(null);
    }
  };

  const processResults = async (finalAnswers) => {
    setSubmitting(true);
    setError('');
    
    try {
      // Check if backend is available
      const backendUrl = import.meta.env.VITE_FIREBASE_FUNCTION_URL;
      
      console.log("Backend URL from env:", backendUrl);
      
      if (backendUrl && user) {
        // Try backend submission
        try {
          console.log("Attempting backend submission...");
          const idToken = await user.getIdToken();
          console.log("Got user token, preparing data...");
          
          // Prepare answers in the format expected by the backend
          const answersObject = {};
          finalAnswers.forEach((answerIndex, questionIndex) => {
            answersObject[questionIndex.toString()] = answerIndex;
          });
          
          const quizId = import.meta.env.VITE_QUIZ_ID || 'web-development-basics';
          console.log(`Using Quiz ID: ${quizId}`);
          
          // For Firebase 2nd Gen functions, the URL patterns work differently
          // Try both with and without /submitQuiz path to ensure compatibility
          const submitUrl = backendUrl.endsWith('/submitQuiz') ? 
            backendUrl : 
            `${backendUrl}/submitQuiz`;
            
          console.log(`Primary submission URL: ${submitUrl}`);
          console.log(`Backup submission URL (if primary fails): ${backendUrl}`);
          
          // Prepare the request options
          const requestOptions = {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${idToken}`
            },
            body: JSON.stringify({
              quizId: quizId,
              answers: answersObject
            })
          };
          
          let result;
          
          // Try with the first URL format
          try {
            console.log("Trying primary URL format...");
            const response = await fetch(submitUrl, requestOptions);
            
            if (!response.ok) {
              const errorData = await response.text();
              console.error(`Backend error with primary URL [${response.status}]:`, errorData);
              
              // Try the backup URL format
              console.log("Primary URL failed, trying backup URL format...");
              const backupResponse = await fetch(backendUrl, requestOptions);
              
              if (!backupResponse.ok) {
                const backupErrorData = await backupResponse.text();
                console.error(`Backend error with backup URL [${backupResponse.status}]:`, backupErrorData);
                throw new Error(`Backend error: ${backupResponse.status} - ${backupErrorData}`);
              }
              
              // Process the successful backup response
              result = await backupResponse.json();
              console.log("Backend response (backup URL):", result);
            } else {
              // Process the successful primary response
              result = await response.json();
              console.log("Backend response (primary URL):", result);
            }
          } catch (fetchError) {
            console.error("Fetch operation failed:", fetchError);
            throw fetchError;
          }
          
          // Navigate to results page with report ID and full analysis
          navigate(`/results/${result.reportId}`, { 
            state: { 
              reportId: result.reportId,
              analysis: result.analysis,
              report: result,  // Include the full report data
              isBackendResult: true,
              message: 'Quiz submitted and analyzed successfully!'
            },
            replace: true 
          });
          return;
          
        } catch (backendError) {
          console.error('Backend submission failed - DETAILED ERROR:', backendError);
          console.error('Error message:', backendError.message);
          console.error('Error stack:', backendError.stack);
          setError(`Backend error: ${backendError.message}`);
        }
      }
      
      // Fallback: Frontend-only processing
      console.log("Using frontend fallback processing...");
      const results = calculateFrontendResults(finalAnswers);
      
      // Create a complete report object similar to what the backend would return
      const fallbackReport = {
        overallPercentage: results.overallScore,
        totalScore: results.correctAnswers,
        totalQuestions: results.totalQuestions,
        classifiedTopics: Object.entries(results.topicBreakdown).reduce((acc, [topic, data]) => {
          const percentage = Math.round((data.correct / data.total) * 100);
          acc[topic] = {
            classification: percentage >= 80 ? "Mastered" : percentage >= 50 ? "Needs Revision" : "Learn from Scratch",
            correct: data.correct,
            total: data.total,
            percentage: percentage
          };
          return acc;
        }, {}),
        submittedAt: new Date().toISOString(),
        userAnswers: results.userAnswers
      };
      
      console.log("Created fallback report:", fallbackReport);
      
      // Navigate to results with frontend-calculated data in a format consistent with backend
      navigate('/results', { 
        state: { 
          ...results,
          report: fallbackReport,
          isBackendResult: false,
          message: backendUrl ? 'Backend unavailable - showing local results' : 'Running in frontend-only mode'
        },
        replace: true 
      });
      
    } catch (error) {
      console.error('Quiz submission failed - CRITICAL ERROR:', error);
      console.error('Error stack:', error.stack);
      setError('Failed to submit quiz. Please try again.');
    } finally {
      setSubmitting(false);
    }
  };

  const calculateFrontendResults = (finalAnswers) => {
    let correctCount = 0;
    const topicScores = {};
    
    finalAnswers.forEach((answerIndex, questionIndex) => {
      const question = qs[questionIndex];
      const isCorrect = answerIndex === question.correctAnswer;
      
      if (isCorrect) {
        correctCount++;
      }
      
      // Track topic performance
      const topic = question.topic || 'General';
      if (!topicScores[topic]) {
        topicScores[topic] = { correct: 0, total: 0 };
      }
      topicScores[topic].total++;
      if (isCorrect) {
        topicScores[topic].correct++;
      }
    });
    
    const overallScore = Math.round((correctCount / total) * 100);
    
    return {
      overallScore,
      totalQuestions: total,
      correctAnswers: correctCount,
      topicBreakdown: topicScores,
      userAnswers: finalAnswers,
      timestamp: new Date().toISOString()
    };
  };

  const handleRestart = () => {
    setCurrent(0);
    setSelected(null);
    setUserAnswers([]);
    setSubmitting(false);
    setError('');
  };

  if (!qs || !qs.length) return null;

  // Show submitting state while processing
  if (submitting) {
    return (
      <div className="quiz-results-container">
        <div className="quiz-results-header">
          <h3 className="quiz-results-title">Processing Quiz...</h3>
        </div>
        <p className="quiz-score">
          {import.meta.env.VITE_CLOUD_FUNCTION_URL 
            ? 'Analyzing your answers and generating your learning roadmap...'
            : 'Calculating your results locally...'
          }
        </p>
        {error && (
          <div className="error-message" style={{color: 'red', marginTop: '1rem'}}>
            {error}
            <button 
              className="btn quiz-restart-btn" 
              onClick={handleRestart}
              style={{marginTop: '1rem'}}
            >
              Try Again
            </button>
          </div>
        )}
      </div>
    );
  }

  return (
    <div className="quiz-container">
      <div className="quiz-header">
        <h3 className="quiz-title">Question {current + 1}</h3>
        <div className="quiz-progress">({current + 1} / {total})</div>
      </div>

      <div className="quiz-question">{q.question}</div>

      <div className="quiz-options">
        {q.options.map((opt, idx) => (
          <button
            key={idx}
            type="button"
            onClick={() => handleSelect(idx)}
            aria-pressed={selected === idx}
            className={`quiz-option ${selected === idx ? 'quiz-option-selected' : ''}`}
          >
            {opt}
          </button>
        ))}
      </div>

      <div className="quiz-footer">
        <div />
        <button
          onClick={handleNext}
          disabled={selected === null}
          className={`btn ${selected === null ? 'btn-disabled' : ''}`}
        >
          {isLast ? 'Finish' : 'Next'}
        </button>
      </div>

      {/* Show backend status */}
      <div style={{ marginTop: '1rem', fontSize: '0.8rem', color: '#666' }}>
        {import.meta.env.VITE_CLOUD_FUNCTION_URL 
          ? 'üîí Secure backend grading enabled'
          : '‚ö†Ô∏è Running in frontend-only mode'
        }
      </div>
    </div>
  );
}
